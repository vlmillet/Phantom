// license [
// This file is part of the Phantom project. Copyright 2011-2020 Vivien Millet.
// Distributed under the MIT license. Text available here at
// https://github.com/vlmillet/phantom
// ]

#pragma once

/* ****************** Includes ******************* */
#include <phantom/lang/Symbol.h>
/* **************** Declarations ***************** */

/* *********************************************** */

namespace phantom
{
namespace lang
{
////////////////////////////////////////////////////////////////////////////////////////////////////
/// \class  AnonymousSection
///
/// \brief  Base implementation for namespace level anonymous structs and unions.
////////////////////////////////////////////////////////////////////////////////////////////////////

class PHANTOM_EXPORT_PHANTOM AnonymousSection : public Symbol
{
    PHANTOM_DECLARE_META_CLASS(AnonymousSection);

public:
    AnonymousSection(Modifiers modifiers = 0, uint a_uiFlags = 0);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief  Convenient cast function.
    ///
    /// \return this instance.
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    AnonymousSection* asAnonymousSection() const override
    {
        return (AnonymousSection*)this;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief  Adds a variable to the section.
    ///
    /// \param [in,out] a_pVariable the variable.
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    void addVariable(Variable* a_pVariable);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief  Gets a variable.
    ///
    /// \param  a_uiIndex   The index.
    ///
    /// \return null if it fails, else the variable.
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    Variable* getVariable(size_t a_uiIndex) const
    {
        return m_Variables[a_uiIndex];
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief  Gets variable count.
    ///
    /// \return The variable count.
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    size_t getVariableCount() const
    {
        return m_Variables.size();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief  Get the list of data elements of this section
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    LanguageElements const& getDataElements() const
    {
        return m_DataElements;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief  Get the list of variables of this section
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    Variables const& getVariables() const
    {
        return m_Variables;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief  Gets the first ascendant not being an anonymous section.
    ///
    /// \return null if it fails, else the root owner.
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    ClassType* getRootOwner() const
    {
        return getOwnerSection() ? getOwnerSection()->getRootOwner()
                                 : getOwner() ? getOwner()->asClassType() : nullptr;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief  Gets the owner section.
    ///
    /// \return null if owner is not an anonymous section, else the owner section.
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    AnonymousSection* getOwnerSection() const
    {
        return getOwner() ? getOwner()->asAnonymousSection() : nullptr;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief  Gets the top level section.
    ///
    /// \return The section.
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    AnonymousSection* getRootSection() const
    {
        return getOwnerSection() ? getOwnerSection()->getRootSection() : (AnonymousSection*)this;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief  Adds a nested anonymous section to this section.
    ///
    /// \param [in,out] a_pAnonymousSection The nested anonymous section.
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    void addAnonymousSection(AnonymousSection* a_pAnonymousSection);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief  Removes a nested anonymous section to this section.
    ///
    /// \param [in,out] a_pAnonymousSection The nested anonymous section.
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    void removeAnonymousSection(AnonymousSection* a_pAnonymousSection);

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief  Gets a nested anonymous section at a given index.
    ///
    /// \param  a_uiIndex   The index.
    ///
    /// \return The requested nested anonymous section.
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    AnonymousSection* getAnonymousSection(size_t a_uiIndex) const
    {
        return m_AnonymousSections[a_uiIndex];
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief  Gets the total count of nested anonymous sections.
    ///
    /// \return The total count.
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    size_t getAnonymousSectionCount() const
    {
        return m_AnonymousSections.size();
    }

protected:
    void onElementAdded(LanguageElement* a_pElement) override;
    void onElementRemoved(LanguageElement* a_pElement) override;
    void onReferencedElementRemoved(LanguageElement* a_pElement) override;

protected:
    Variables         m_Variables;
    AnonymousSections m_AnonymousSections;
    LanguageElements  m_DataElements;
};

} // namespace lang
} // namespace phantom
